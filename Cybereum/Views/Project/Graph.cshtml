@*@page*@
@*@inject Cybereum.GraphService GraphService*@
<html>
<head>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <style>
        .node {
            fill: #fff;
            stroke: steelblue;
            stroke-width: 1.5px;
        }

        .link {
            stroke: #d2fbff;
            stroke-opacity: 0.9;
        }
    </style>
</head>
<body>
    <script>
        
        function uploadFile(event) {
            var input = event.target;
            var reader = new FileReader();
            reader.onload = function () {
                var text = reader.result;
                var data = d3.csvParse(text);
                generateGraph(data);
            };
            reader.readAsText(input.files[0]);
        }
        
      
        //var graphService = new GraphService("gremtest1.gremlin.cosmosdb.azure.com", 443, "lja6Gkeuf5nsnEg9TYyC79N1fvt4v1ZBb9JwkbWPNiNC1tEeBOSVu8vBHQZeKnSFguIKz9ziKjVEiPAjRAuf3w==", "graphdb", "Graph7");

        graphService.GetGraphDataAsync().then(function (graphData) {
            generateGraph(graphData);
        });
        
        function generateGraph(data) {
            debugger;
            //var nodes = graphData.Nodes;
            //var links = graphData.Links;
            var nodes = [];
            var links = [];
            data.forEach(function (d) {
                debugger;
                var sourceNode = nodes.find(function (n) {
                    return n.name === d.source;
                });
                if (!sourceNode) {
                    sourceNode = { name: d.source, degree: 0 };
                    nodes.push(sourceNode);
                }
                var targetNode = nodes.find(function (n) {
                    return n.name === d.target;
                });
                if (!targetNode) {
                    targetNode = { name: d.target, degree: 0 };
                    nodes.push(targetNode);
                }
                sourceNode.degree++;
                targetNode.degree++;
                links.push({ source: sourceNode, target: targetNode, value: d.value });
            });
            var maxDegree = d3.max(nodes, function (d) { return d.degree; });
            var minRadius = 5;
            var maxRadius = 30;
            var radiusScale = d3.scaleLinear()
                .domain([1, maxDegree])
                .range([minRadius, maxRadius]);

            var width = 2000, height = 1500;
            var svg = d3.select("body").append("svg")
                .attr("width", width)
                .attr("height", height);
            var simulation = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(links).id(function (d) { return d.name; }).strength(0.5).distance(100))
                .force("charge", d3.forceManyBody().strength(-200))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .force("collide", d3.forceCollide().radius(15))
                .force("link", d3.forceLink(links).id(function (d) { return d.name; }).distance(function (d) { return d.value; }))

            var linkForce = d3.forceLink(links)
                .id(function (d) { return d.name; })
                .distance(function (d) {
                    var dist = d.value + 100; // add 50 to distance to increase space between links
                    return dist;
                })
                .strength(0.5);

            var link = svg.selectAll(".link")
                .data(links)
                .enter().append("line")
                .attr("class", "link")
                .attr("marker-end", "url(#end)")
                .style("stroke-width", function (d) { return Math.sqrt(d.value) / 2; });


            linkForce.distance(function (d) {
                var dx = d.target.x - d.source.x;
                var dy = d.target.y - d.source.y;
                var distance = Math.sqrt(dx * dx + dy * dy);
                // If the distance is too small, set it to a minimum value to avoid collisions
                if (distance < 30) {
                    distance = 30;
                }
                return distance;
            });
            simulation.force("link", linkForce);

            var node = svg.selectAll(".node")
                .data(nodes)
                .enter().append("circle")
                .attr("class", "node")
                .attr("r", function (d) { return radiusScale(d.degree); })
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));

            node.append("title")
                .attr("x", -10)
                .attr("dy", "1.9em")
                .attr("font-size", "10px")
                .attr("class", "shadow")
                .text(function (d) { return d.name; });
            node.append("text")
                .attr("class", "aa")
                .attr("x", -1)
                .attr("dy", ".35em")
                .attr("font-size", "8px")
                .attr("class", "shadow")
                .attr("text-anchor", "middle")
                //.text(function (d) { var str1 = d.name; var res = str1.split(" "); var res2 = res[0]; return res2; })
                .text("aa")
                .style({ opacity: '0.8' })

            simulation.on("tick", function () {
                link.attr("x1", function (d) { return d.source.x; })
                    .attr("y1", function (d) { return d.source.y; })
                    .attr("x2", function (d) { return d.target.x; })
                    .attr("y2", function (d) { return d.target.y; });
                node.attr("cx", function (d) { return d.x; })
                    .attr("cy", function (d) { return d.y; });
            });

            simulation
                .force("link", linkForce)
                .on("tick", ticked);

            function ticked() {
                link
                    .attr("x1", function (d) { return d.source.x; })
                    .attr("y1", function (d) { return d.source.y; })
                    .attr("x2", function (d) { return d.target.x; })
                    .attr("y2", function (d) { return d.target.y; });

                node
                    .attr("transform", function (d) {
                        return "translate(" + d.x + "," + d.y + ")";
                    })
            }

            function dragstarted(d) {
                if (!d3.event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(d) {
                d.fx = d3.event.x;
                d.fy = d3.event.y;
            }

            function dragended(d) {
                if (!d3.event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }

            // build the arrow.
            svg.append("svg:defs").selectAll("marker")
                .data(["end"])      // Different link/path types can be defined here
                .enter().append("svg:marker")    // This section adds in the arrows
                .attr("id", String)
                .attr("viewBox", "0 -5 10 10")
                .attr("refX", function (d) { return 20 + 1; })   // use a function to calculate the offset based on circle radius
                .attr("refY", 0)
                .attr("markerWidth", 3)
                .attr("markerHeight", 4)
                .attr("orient", "auto")
                .append("svg:path")
                .attr("d", "M0,-5L10,0L0,5");
        }
    </script>
    <input type="file" accept=".csv" onchange="uploadFile(event)">
    </body>
</html>
